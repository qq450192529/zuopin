<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>demo2</title>
    <script>
        function loadXMLDoc() {
            var xmlhttp;
            if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                xmlhttp = new XMLHttpRequest();
            } else { // code for IE6, IE5
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
            }
            //为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。
            //如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：

            // xmlhttp.open("GET", "./data.php", false);
            // xmlhttp.send();
            //async：true（异步）或 false（同步）。  当同步时将下面的执行函数放在下方。
            //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。
            //请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。
            // false(同步)的话，执行到AJAX后，所有代码都要等待请求，请求成功再继续执行。容易页面假死奔溃

            xmlhttp.onreadystatechange = function() {
                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                    document.getElementById("myDiv").innerHTML = xmlhttp.responseText;
                    ///responseText()获得字符串形式的响应数据。
                }
            }
            xmlhttp.open("GET", "./data.php", true);
            xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xmlhttp.send("fname=Bill&lname=Gates");
        }
        /*
            百度资料
            在这里，async默认的设置值为true，这种情况为异步方式，就是说当ajax发送请求后，
            在等待server端返回的这个过程中，前台会继续 执行ajax块后面的脚本，
            直到server端返回正确的结果才会去执行success，
            也就是说这时候执行的是两个线程，ajax块发出请求后一个线程
            和ajax块后面的脚本（另一个线程）

            自我理解：
            简单来就说，就是true(异步)的情况下，
            等待数据的同时也会执行下面的脚本，不会一直等待。
        */


        function loadXMLDoc2() {
            var xmlhttp;
            var txt, x, i;
            if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                xmlhttp = new XMLHttpRequest();
            } else { // code for IE6, IE5
                xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                ///microsoft随便改不会有事
            }
            xmlhttp.onreadystatechange = function() {
                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                    xmlDoc = xmlhttp.responseXML;
                    console.log(xmlDoc);
                    //输出日志是null，未成功获取
                    //证明下方错误锁定正确
                    //问题在于XML文档，W3C的可以正确打开，我的却是要直接保存
                    //

                    //如果来自服务器的响应是 XML，
                    //而且需要作为 XML 对象进行解析，
                    //请使用 responseXML 属性来请求XML文件
                    /*
                    XML详解http://www.ibm.com/developerworks/cn/xml/x-newxml/
                    */
                    txt = "";
                    x = <xmlDoc className="getElementsByTa"></xmlDoc>gName("title");
                    //在这一步报错。
                    //Cannot read property 'getElementsByTagName' of null
                    //阅读外文文档得知原因在于并未成功获取到XML文档，老外靠谱啊。。
                    for (i = 0; i < x.length; i++) {
                        txt = txt + x[i].childNodes[0].nodeValue + "<br />";
                    }
                    document.getElementById("myDiv2").innerHTML = txt;
                }
            }
            // xmlhttp.open("GET", "http://www.w3school.com.cn/example/xmle/books.xml", true);
            xmlhttp.open("POST", "./books.xml", true);
            xmlhttp.send();
        }
    </script>
</head>

<body>
    <div id="myDiv">请求后的数据放在这里</div>
    <button type="button" onclick="loadXMLDoc()">请求数据</button>
    <div id="myDiv2">XML请求的数据</div>
    <button onclick="loadXMLDoc2()">请求数据XML</button>

</body>

</html>
